import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'package:geolocator/geolocator.dart';

void main() => runApp(const WeatherApp());

/// TODO: paste your real OpenWeather key here (string).
const String kOpenWeatherKey = "PASTE_YOUR_OPENWEATHER_KEY_HERE";
const String kOWBase = "https://api.openweathermap.org/data/2.5/weather";

/// Turn this on to auto-fallback to Open-Meteo when OpenWeather returns 401.
const bool kEnableFallback = true;

class WeatherApp extends StatelessWidget {
  const WeatherApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Weather App',
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),
        useMaterial3: true,
      ),
      home: const WeatherHome(),
    );
  }
}

class WeatherHome extends StatefulWidget {
  const WeatherHome({super.key});
  @override
  State<WeatherHome> createState() => _WeatherHomeState();
}

class _WeatherHomeState extends State<WeatherHome> {
  final TextEditingController _cityCtrl = TextEditingController();
  bool _loading = false;
  String? _error;
  String? _cityName;
  double? _tempC;
  String? _desc;
  String? _iconUrl;

  @override
  void dispose() {
    _cityCtrl.dispose();
    super.dispose();
  }

  // ------------------ UI actions ------------------

  Future<void> _useLocation() async {
    setState(() { _loading = true; _error = null; });
    try {
      var perm = await Geolocator.checkPermission();
      if (perm == LocationPermission.denied) {
        perm = await Geolocator.requestPermission();
      }
      if (perm == LocationPermission.denied ||
          perm == LocationPermission.deniedForever) {
        throw Exception("Location permission denied");
      }
      final pos = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.medium,
      );
      await _fetchOpenWeatherByCoords(pos.latitude, pos.longitude);
    } catch (e) {
      setState(() => _error = e.toString());
    } finally {
      setState(() => _loading = false);
    }
  }

  Future<void> _searchCity() async {
    final city = _cityCtrl.text.trim();
    if (city.isEmpty) return;
    setState(() { _loading = true; _error = null; });
    try {
      await _fetchOpenWeatherByCity(city);
    } catch (e) {
      setState(() => _error = e.toString());
    } finally {
      setState(() => _loading = false);
    }
  }

  // ------------------ OpenWeather ------------------

  Future<void> _fetchOpenWeatherByCity(String city) async {
    final uri = Uri.parse("$kOWBase?q=$city&appid=$kOpenWeatherKey&units=metric");
    await _performOpenWeather(uri, fallbackCity: city);
  }

  Future<void> _fetchOpenWeatherByCoords(double lat, double lon) async {
    final uri = Uri.parse("$kOWBase?lat=$lat&lon=$lon&appid=$kOpenWeatherKey&units=metric");
    await _performOpenWeather(uri, fallbackCoords: (lat, lon));
  }

  Future<void> _performOpenWeather(
    Uri uri, {
    String? fallbackCity,
    (double, double)? fallbackCoords,
  }) async {
    // Helpful logging in your debug console:
    // print("→ GET $uri");
    final res = await http.get(uri);
    // print("← ${res.statusCode} ${res.body}");

    if (res.statusCode == 200) {
      final data = jsonDecode(res.body) as Map<String, dynamic>;
      setState(() {
        _cityName = data['name'] as String?;
        _tempC = (data['main']['temp'] as num).toDouble();
        _desc = (data['weather'][0]['description'] as String);
        final icon = data['weather'][0]['icon'] as String;
        _iconUrl = "https://openweathermap.org/img/wn/${icon}@2x.png";
      });
    } else if (res.statusCode == 401 && kEnableFallback) {
      // Unauthorized → likely bad/missing key; switch to Open-Meteo so UI still works.
      if (fallbackCoords != null) {
        await _fetchOpenMeteoByCoords(fallbackCoords.$1, fallbackCoords.$2);
      } else if (fallbackCity != null) {
        await _fetchOpenMeteoByCity(fallbackCity);
      }
      setState(() {
        _error = "OpenWeather 401 (check API key). Showing fallback data.";
      });
    } else {
      final msg = _extractOpenWeatherError(res.body);
      throw Exception("HTTP ${res.statusCode}${msg != null ? ': $msg' : ''}");
    }
  }

  String? _extractOpenWeatherError(String body) {
    try {
      final m = jsonDecode(body);
      if (m is Map && m['message'] != null) return m['message'].toString();
    } catch (_) {}
    return null;
  }

  // ------------------ Fallback: Open-Meteo (no key) ------------------

  Future<void> _fetchOpenMeteoByCity(String city) async {
    // 1) geocode city → lat/lon
    final geo = Uri.parse(
        "https://geocoding-api.open-meteo.com/v1/search?name=$city&count=1&language=en&format=json");
    final gRes = await http.get(geo);
    if (gRes.statusCode != 200) {
      throw Exception("Geocoding failed ${gRes.statusCode}");
    }
    final g = jsonDecode(gRes.body);
    if (g['results'] == null || (g['results'] as List).isEmpty) {
      throw Exception("City not found");
    }
    final first = g['results'][0];
    final lat = (first['latitude'] as num).toDouble();
    final lon = (first['longitude'] as num).toDouble();
    final name = first['name'] as String;

    await _fetchOpenMeteoByCoords(lat, lon, overrideCity: name);
  }

  Future<void> _fetchOpenMeteoByCoords(double lat, double lon, {String? overrideCity}) async {
    final uri = Uri.parse(
        "https://api.open-meteo.com/v1/forecast?latitude=$lat&longitude=$lon&current_weather=true");
    final res = await http.get(uri);
    if (res.statusCode != 200) {
      throw Exception("Open-Meteo failed ${res.statusCode}");
    }
    final data = jsonDecode(res.body);
    final cw = data['current_weather'];
    final temp = (cw['temperature'] as num).toDouble();
    final code = cw['weathercode'] as int;
    setState(() {
      _cityName = overrideCity ?? "Your location";
      _tempC = temp;
      _desc = _mapWeatherCode(code);
      _iconUrl = null; // no icon from Open-Meteo (you can map your own)
    });
  }

  String _mapWeatherCode(int code) {
    // Simple mapping (expand if you want)
    if (code == 0) return "Clear sky";
    if ([1, 2].contains(code)) return "Mostly clear";
    if (code == 3) return "Overcast";
    if ([45, 48].contains(code)) return "Fog";
    if ([51, 53, 55].contains(code)) return "Drizzle";
    if ([61, 63, 65].contains(code)) return "Rain";
    if ([71, 73, 75].contains(code)) return "Snow";
    if ([80, 81, 82].contains(code)) return "Rain showers";
    if ([95, 96, 99].contains(code)) return "Thunderstorm";
    return "Unknown";
  }

  // ------------------ UI ------------------

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text("Weather App"),
        centerTitle: true,
        actions: [
          IconButton(
            tooltip: "Use my location",
            onPressed: _useLocation,
            icon: const Icon(Icons.my_location),
          ),
        ],
      ),
      body: Container(
        decoration: BoxDecoration(
          gradient: LinearGradient(
            colors: [Colors.blue.shade50, Colors.blue.shade100, Colors.white],
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
          ),
        ),
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            Row(
              children: [
                Expanded(
                  child: TextField(
                    controller: _cityCtrl,
                    textInputAction: TextInputAction.search,
                    onSubmitted: (_) => _searchCity(),
                    decoration: InputDecoration(
                      hintText: "Enter city (e.g., Delhi)",
                      filled: true,
                      fillColor: Colors.white,
                      contentPadding: const EdgeInsets.symmetric(horizontal: 14, vertical: 12),
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(12),
                        borderSide: BorderSide.none,
                      ),
                    ),
                  ),
                ),
                const SizedBox(width: 8),
                ElevatedButton.icon(
                  onPressed: _searchCity,
                  icon: const Icon(Icons.search),
                  label: const Text("Search"),
                ),
              ],
            ),
            const SizedBox(height: 16),
            if (_loading) const Padding(
              padding: EdgeInsets.all(24.0),
              child: CircularProgressIndicator(),
            ),
            if (_error != null && !_loading)
              Padding(
                padding: const EdgeInsets.all(8.0),
                child: Text(_error!, style: const TextStyle(color: Colors.red)),
              ),
            const SizedBox(height: 8),
            if (_cityName != null && !_loading)
              _WeatherCard(city: _cityName!, tempC: _tempC!, desc: _desc!, iconUrl: _iconUrl),
            const Spacer(),
            Text(
              "Tip: target icon uses GPS. If OpenWeather key isn’t set, fallback data will show.",
              style: TextStyle(color: Colors.grey.shade700),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }
}

class _WeatherCard extends StatelessWidget {
  final String city;
  final double tempC;
  final String desc;
  final String? iconUrl;

  const _WeatherCard({
    required this.city,
    required this.tempC,
    required this.desc,
    required this.iconUrl,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: 8,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Padding(
        padding: const EdgeInsets.all(20.0),
        child: Column(
          children: [
            Text(city, style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold)),
            const SizedBox(height: 8),
            if (iconUrl != null) Image.network(iconUrl!, width: 90, height: 90),
            const SizedBox(height: 8),
            Text("${tempC.toStringAsFixed(1)} °C",
                style: const TextStyle(fontSize: 34, fontWeight: FontWeight.w600)),
            const SizedBox(height: 6),
            Text(desc, style: TextStyle(fontSize: 18, color: Colors.grey.shade700, fontStyle: FontStyle.italic)),
          ],
        ),
      ),
    );
  }
}
